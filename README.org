#+title: Clojure Project

I want the minimal stuff

- Certain pages with fixed structure (like =index.html=) will be pre-rendered
- Metadata: That will be defined in the <head> section a single time
- HTML: I will use pure clojure to generate the static stuff, backing in the numbers from csvs
- JS: For stuff like gallery interactivity, I will manipulate the dom and generate js for this
- CSS: This will scan the files - as long as I use full css class names, it will generate a shaken config
- Assets: Some will be generated as above, others will be pre-defined

Figwheel: great for development and refreshing the page. As I will be doing a static build, I will probably not be using it that much
Clojure: most of the stuff is going to be written and evaled in closure
Serving: I would like a way of viewing the effects of the builds. I don't really have any complex states, so it should be pain-free

- [[https://bigv-portfolio.goatcounter.com/counter//.svg?no_branding=true][Home page views]]
- [[https://bigv-portfolio.goatcounter.com/counter//gallery/.svg?no_branding=true][Gallery page views]]

* Generating hashes for external js
#+begin_src shell
curl -sSL https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.min.js \
  | openssl dgst -sha384 -binary \
  | openssl base64 -A \
  | awk '{print "sha384-" $0}'
#+end_src
* Config
** =.clj=
** =.cljs=
As the cljs files are compiled and minified with the =cljs= compiler, variable names can be mangled.

To prevent this, ensure that you use =aget= instead of =-.PROP= to access fields

#+begin_src clojure
-                   (let [idx   (js/parseInt (.-dataIndex item))
+                   (let [idx   (js/parseInt (aget item "dataIndex"))
#+end_src

*** How to build
- The =cljs= compiler does a good job at slimming the build and can be used as is.
- I looked at using it to create a temp output and then using =rollup= to bundle and trim further: commit 2917629
- It seemed to be worse as per table below as it did not group common things
| =cljs= + tree-shakeng =chart.js= | =gallery.js=       | 2.56k |
|                                  | =landing.js=       | 167k  |
|                                  | =cljs_base.js=     | 99.5k |
|----------------------------------+--------------------+-------|
| =cljs=                           | =gallery.js=       | 2.55k |
|                                  | =landing.js=       | 7.46k |
|                                  | =cljs_base.js=     | 98.7k |
|                                  | =chart.umd.min.js= | 203k  |
|----------------------------------+--------------------+-------|
| =cljs + rollup=                  | =gallery.js=       | 92.9k |
|                                  | =landing.js=       | 103k  |
|                                  | =chart.umd.min.js= | 203k  |

* Running
#+begin_src shell
npm i # initiall install
npm run dev # for development build with watching
npm run build # for production build
npm run publish # to push to github pages
#+end_src

* TODO
- [X] Need to embed the graph - no toggling to begin with
- [X] Build for landing an gallery pages, preferable through a slim config file
- [X] Separating out common element (data) into cljc files that can be consumed by both sources
- [ ] Rework the build pipeline for =cljs= so that it builds the relevant files into relevant =js= files
- [ ] Tree shake =charts.js= and make a simple build script
- [ ] Clean up the code into modules
